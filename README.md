 مقدمه

این پروژه در قالب یک چالش Clean Code بک‌اند انجام شده است.  
هدف چالش، صرفاً ساختن یک API ساده نبود، بلکه تمرکز اصلی روی موارد زیر بوده است:

- طراحی معماری تمیز و قابل توسعه
- جداسازی منطق کسب‌وکار از فریم‌ورک
- نوشتن تست واقعی و معنادار
- آماده‌سازی پروژه برای تحویل حرفه‌ای (Production‑ready)

در طول انجام پروژه، تصمیمات فنی متعددی گرفته شد که همگی در راستای
**پایداری، خوانایی و تست‌پذیری کد** بوده‌اند.

---

## شروع پروژه (FastAPI)

در ابتدای کار، پروژه به‌صورت نمونه با FastAPI آغاز شد.  
FastAPI انتخاب مناسبی برای شروع سریع است و امکان پیاده‌سازی API با حداقل کد را می‌دهد.

اما پس از بررسی دقیق‌تر نیازهای چالش، مشخص شد که:

- تمرکز اصلی، «سرعت توسعه» نیست
تمرکز روی معماری و مدل ذهنی درست است
- لازم است منطق پروژه کاملاً مستقل از فریم‌ورک باشد

اینجا بود که تصمیم مهاجرت گرفته شد.

---

## تصمیم مهاجرت از FastAPI به Django

مهاجرت از FastAPI به Django کاملاً آگاهانه انجام شد، نه از روی اجبار.

دلایل اصلی انتخاب Django:

- ساختار استاندارد و پایدار
- رایج بودن در محیط‌های سازمانی
- جداسازی شفاف View، URL و Service
- هماهنگی عالی با Django REST Framework

نکته مهم:
> هدف از مهاجرت، تغییر فریم‌ورک بود، نه تغییر منطق.

منطق اصلی پروژه بدون تغییر حفظ شد و فقط لایه API بازطراحی شد.

---

## طراحی معماری (Clean Architecture)

از ابتدا تصمیم گرفته شد معماری پروژه بر اساس تفکیک مسئولیت‌ها طراحی شود

Service Layer (قلب پروژه)
مهم‌ترین تصمیم معماری پروژه، ایجاد Service Layer خالص بود

ویژگی‌های این لایه:
- هیچ وابستگی‌ای به Django ندارد
- مستقل از دیتابیس است
- قابل تست بدون اجرای سرور
- قابل استفاده در هر فریم‌ورکی (Django / FastAPI / …)

در این پروژه، منطق مربوط به Wallet (مانند بررسی وضعیت سرویس)
در فایل `wallet_service.py` پیاده‌سازی شد.

این طراحی باعث شد:
- تغییر فریم‌ورک ساده باشد
- تست‌نویسی واقعی امکان‌پذیر شود
- کد قابل خواندن و قابل دفاع باشد

## پیاده‌سازی API (Django + DRF)
لایه API فقط وظیفه دارد:

- Request را دریافت کند
- Service Layer را صدا بزند
- Response مناسب برگرداند

هیچ منطق بیزینسی داخل View نوشته نشده است.

به این ترتیب:
- View نازک (Thin Controller)
- Service ضخیم (Fat Service)
- وابستگی کم
- تست‌پذیری بالا

## Docker و زیرساخت

پروژه با استفاده از Docker و Docker Compose اجرا می‌شود.

اجزای زیرساخت:

- Python 3.12
- Django
- Django REST Framework
- MongoDB
- Pipenv برای مدیریت وابستگی‌ها

در این مرحله چالش‌های متعددی حل شد، از جمله:
- خطای 502
- عدم وجود وابستگی‌ها (DRF)
- ناسازگاری نسخه پایتون
- قفل قدیمی Pipenv

در نهایت:
- همه سرویس‌ها پایدار شدند
- Django به‌درستی بالا آمد
- MongoDB سالم و Healthy شد

در نهایت:
- همه سرویس‌ها پایدار شدند
- Django به‌درستی بالا آمد
- MongoDB سالم و Healthy شد

## تست‌نویسی (Unit Test واقعی)

برای اثبات تمیز بودن معماری، یک **Unit Test خالص** نوشته شد.

ویژگی‌های تست:

- استفاده از `pytest`
- بدون نیاز به Docker
- بدون دیتابیس
- بدون Django

تمرکز تست فقط روی **منطق Wallet** است، نه فریم‌ورک.

یکی از چالش‌های مهم این مرحله:
- Import Error
- PYTHONPATH
- ترتیب لود شدن ماژول‌ها

در نهایت با اصلاح ساختار فایل Service و تعریف توابع خالص در ابتدای فایل،
تست به‌صورت کامل و پایدار اجرا شد:


---

## نتیجه نهایی

در پایان این چالش:

- ✅ مهاجرت موفق از FastAPI به Django
- ✅ معماری Clean Architecture پیاده‌سازی شده
- ✅ Service Layer مستقل و قابل تست
- ✅ Unit Test واقعی و ایزوله
- ✅ زیرساخت Docker پایدار
- ✅ Commit و Version Control تمیز

